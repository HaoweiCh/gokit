系列文章的第二篇, go-kit + grpc的实现有我自己编写的示例04中的实现有很大区别, 相比起来第一篇与我自己的实现倒相差不多, 就是说ta的两个工程存在有较大差异的.

首先, 示例04中把业务层作为核心, grpc在外层作一个封装, 所以需要把业务层的方法在transport再声明一遍, 用于暴露给客户端使用. 

所以客户端连接后可用的方法是transport中实现了`protobuf`文件中`service`结构定义的那些, 使用的参数也是`protobuf`定义的`message`结构

而第二篇文章给出的示例, 从客户端调用层面来看, 是直接可以调用业务层的方法的, 连参数都不是`protobuf`的结构. 要知道在使用`grpc`协议时, 所有参数与响应必须为`protobuf`中定义的`message`, 其中做的转换可以说是非常巧妙了.

但是在`client.go`文件中, 客户端实例化连接时`New()`方法中的代码让我产生了一丝疑惑. 如果业务层有多个方法时如何暴露给客户端调用? 是不是要在`Endpoints`结构中再添加其他的业务方法? 这样的话客户端在实例化`Endpoints`时就要通过一个grpc连接对象创建多个`Endpoint`了吧? 想想就觉得麻烦.

我目前仍然无法判断哪种定义方法符合最佳实践, 客户端直接调用服务端业务层函数其实蛮有吸引力, 因为方便了很多, 而且请求/响应的参数也肯定是经过转换, 只不过变得更为隐式而已.